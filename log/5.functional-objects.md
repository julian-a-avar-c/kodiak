# Functional Objects

## `Rational` specification

A `Rational` represents a rational number (a fraction) with a numerator and denominator. It should automatically reduce fractions to their simplest form and handle basic arithmetic operations:

```kodiak
{?} Requirements:
{?} - Store numerator and denominator
{?} - Automatically reduce to lowest terms
{?} - Handle arithmetic operations (+, -, *, /)
{?} - Provide text representation
{?} - Handle negative numbers correctly
```

## Constructing a `Rational`

```kodiak
plex rational(n :int, d :int) =>
  require d != 0, "Denominator cannot be zero"

  {?} Calculate greatest common divisor
  fn gcd(a :int, b :int) :int =>
    if b == 0 then math.abs(a)
    else gcd(b, a % b)

  {?} Reduce fraction and handle sign
  val g = gcd(n, d)
  val numer = if d < 0 then -(n / g) else n / g
  val denom = math.abs(d) / g

  fn numerator :int => numer
  fn denominator :int => denom
end rational

{?} Usage:
val half = :rational(1, 2)
val quarter = :rational(2, 8)    {?} Automatically reduced to 1/4
val negative = :rational(-3, 4)
```

## Adding fields

Fields in plexes can be accessed directly or through methods:

```kodiak
plex rational(n :int, d :int) =>
  require d != 0, "Denominator cannot be zero"

  val g = gcd(n, d)
  val numer = if d < 0 then -(n / g) else n / g
  val denom = math.abs(d) / g

  {?} Public field access
  field numerator :int = numer
  field denominator :int = denom

  {?} Private helper method
  private fn gcd(a :int, b :int) :int =>
    if b == 0 then math.abs(a)
    else gcd(b, a % b)

  fn to-string :text =>
    if denom == 1 then numer.to-string
    else numer.to-string + "/" + denom.to-string
end rational

{?} Usage:
val r = :rational(6, 9)
printline(r.numerator)    {?} 2
printline(r.denominator)  {?} 3
printline(r.to-string)    {?} "2/3"
```

## Self references

Use `this` to refer to the current instance:

```kodiak
plex rational(n :int, d :int) =>
  {?} ... constructor logic ...

  fn add(that :rational) :rational =>
    rational(
      this.numerator * that.denominator + that.numerator * this.denominator,
      this.denominator * that.denominator
    )

  fn equals(that :rational) :bool =>
    this.numerator == that.numerator && this.denominator == that.denominator

  fn compare-to(that :rational) :int =>
    val diff = this.numerator * that.denominator - that.numerator * this.denominator
    if diff < 0 then -1
    else if diff > 0 then 1
    else 0

  {?} Method chaining
  fn negate :rational =>
    rational(-this.numerator, this.denominator)

  fn reciprocal :rational =>
    rational(this.denominator, this.numerator)
end rational

val r = :rational(6, 9)
printline(r.numerator)    {?} 2
printline(r.denominator)  {?} 3
printline(r.to-string)    {?} "2/3"
printline(r.negate.reciprocal)    {?} "-2/3"
```

## Auxiliary constructors

Provide alternative ways to construct objects:

```kodiak
plex rational(n :int, d :int) =>
  {?} Primary constructor logic...

  {?} Auxiliary constructor for whole numbers
  constructor(n :int) => this(n, 1)

  {?} Auxiliary constructor from decimal
  constructor(decimal :float64) =>
    val precision = 1000000
    this((decimal * precision).to-int, precision)
end rational

{?} Factory methods as an alternative approach
plex rational(n :int, d :int) =>
  {?} ... main implementation ...
end rational

{?} Companion object with factory methods
plex rational =
  fn from-int(n :int) :rational => rational(n, 1)

  fn from-decimal(decimal :float64) :rational =>
    val precision = 1000000
    rational((decimal * precision).to-int, precision)

  fn zero :rational => rational(0, 1)
  fn one :rational => rational(1, 1)
end rational

{?} Usage:
val r1 = rational(3, 4)
val r2 = rational.from-int(5)
val r3 = rational.from-decimal(0.75)
val r4 = rational.zero
```

## Private fields and methods

Control access to internal implementation details:

```kodiak
plex rational(n :int, d :int) =>
  require d != 0, "Denominator cannot be zero"

  {?} Private fields - only accessible within this plex
  private val g = gcd(n, d)
  private val numer = if d < 0 then -(n / g) else n / g
  private val denom = math.abs(d) / g

  {?} Private helper method
  private fn gcd(a :int, b :int) :int =>
    if b == 0 then math.abs(a)
    else gcd(b, a % b)

  {?} Public read-only properties
  fn numerator :int => numer
  fn denominator :int => denom

  {?} Public methods
  fn add(that :rational) :rational =>
    rational(
      numer * that.denominator + that.numerator * denom,
      denom * that.denominator
    )

  {?} Private validation method
  private fn validate-non-zero(value :int) :unit =>
    require value != 0, "Value cannot be zero"

  fn divide(that :rational) :rational =>
    validate-non-zero(that.numerator)
    this.multiply(that.reciprocal)
end rational
```

You can even have private primary constructors

```kodiak
plex rational private(a :int, b :int) =>
  require a != 0, "Numerator cannot be zero"
  fn rational(f :float) =>
    rational(f.toLong, 1000000000)
```

## Defining operators

Make your plexes work naturally with Kodiak's operators:

```kodiak
plex rational(n :int, d :int) =>
  {?} ... constructor and private members ...

  {?} Arithmetic operators
  fn +(that :rational) :rational =>
    rational(
      numer * that.denominator + that.numerator * denom,
      denom * that.denominator
    )

  fn -(that :rational) :rational =>
    rational(
      numer * that.denominator - that.numerator * denom,
      denom * that.denominator
    )

  fn *(that :rational) :rational =>
    rational(numer * that.numerator, denom * that.denominator)

  fn /(that :rational) :rational =>
    rational(numer * that.denominator, denom * that.numerator)

  {?} Unary operators
  fn unary-+ :rational => this
  fn unary-- :rational => rational(-numer, denom)

  {?} Comparison operators
  fn <(that :rational) :bool =>
    numer * that.denominator < that.numerator * denom

  fn <=(that :rational) :bool =>
    numer * that.denominator <= that.numerator * denom

  fn >(that :rational) :bool =>
    numer * that.denominator > that.numerator * denom

  fn >=(that :rational) :bool =>
    numer * that.denominator >= that.numerator * denom

  {?} Equality operators
  fn ==(that :rational) :bool =>
    numer == that.numerator && denom == that.denominator

  fn !=(that :rational) :bool =>
    !(this == that)
end rational

{?} Usage:
val r1 = :rational(1, 2)
val r2 = :rational(1, 3)

val sum = r1 + r2        {?} 5/6
val diff = r1 - r2       {?} 1/6
val product = r1 * r2    {?} 1/6
val quotient = r1 / r2   {?} 3/2
val negated = -r1        {?} -1/2

val is-greater = r1 > r2  {?} true
val are-equal = r1 == r2  {?} false
```

## Identifiers in Kodiak

Kodiak supports flexible identifier naming conventions:

```kodiak
{?} Standard identifiers
val simple-name = 42
val camelCase = "hello"
val snake_case = true
val CONSTANT-VALUE = 100

{?} Operators as identifiers
fn +(other :int) :int => this.value + other
fn <=>(other :comparable) :int => this.compare-to(other)

{?} Unicode identifiers
val π = 3.14159
val α = "alpha"
val ∑ = sum-function

{?} Escaped identifiers for keywords
val `type` = "string"
val `match` = pattern-matcher
val `if` = conditional-expression

{?} Method names with special characters
fn `[is-=] :text => "formatted"
fn `== :bool => size == 0
fn `[   ](value :int) :unit => this.value = value

{?} Infix operator methods
plex point(x :int, y :int) =>
  fn -distance-to-(other :point) :float64 =>
    val dx = x - other.x
    val dy = y - other.y
    math.sqrt(dx * dx + dy * dy)
end point

{?} Usage with infix notation
val p1 = point(0, 0)
val p2 = point(3, 4)
val dist = (p1 distance-to p2) {?} 5.0
```

## Method overloading

Kodiak supports method overloading based on parameter types and arity:

```kodiak
plex calculator() =>
  {?} Overloaded add methods
  fn add(a :int, b :int) :int => a + b
  fn add(a :float64, b :float64) :float64 => a + b
  fn add(a :text, b :text) :text => a + b
  fn add(numbers :[int]) :int => numbers.sum

  {?} Overloaded format methods
  fn format(value :int) :text => value.to-string
  fn format(value :float64) :text =>
    f"[%.2f].format(value)
  fn format(value :float64, precision :int) :text =>
    f"[%.*f].format(precision, value)
end calculator

val calc = calculator()

{?} Method resolution based on argument types
val int-sum = calc.add(1, 2)           {?} int version
val float-sum = calc.add(1.5, 2.3)     {?} float64 version
val text-sum = calc.add("[Hello], "[ World])  {?} text version
val list-sum = calc.add([1, 2, 3, 4])  {?} list version

val simple = calc.format(42)           {?} "[42]
val precise = calc.format(3.14159)     {?} "[3.14]
val custom = calc.format(3.14159, 4)   {?} "[3.1416]
```

## Extension methods

Add methods to existing types without modifying their definitions:

```kodiak
{?} Extend built-in types
extension (this :int) =>
  fn is-even :bool => this % 2 == 0
  fn is-odd :bool => !this.is-even?
  fn factorial :int =>
    if this <= 1 then 1
    else this * (this - 1).factorial
  fn times(action :unit => :unit) :unit =>
    for i = 1 to this do action()
end extension

{?} Extend text type
extension (this :text) =>
  fn is-palindrome? :bool =>
    val clean = this.to-lower-case.replace-all("[^a-z]", "")
    clean == clean.reverse

  fn word-count :int =>
    this.split("\\s+").length

  fn abbreviate(max-length :int) :text =>
    if this.length <= max-length then this
    else this.substring(0, max-length - 3) + "..."
end extension

{?} Extend collection types
extension (T :type)(this :[T]) =>
  fn second :option[T] =>
    if this.length >= 2 then some(this[1])
    else none

  fn last-option :option[T] =>
    if this.is-empty then none
    else some(this[this.length - 1])

  fn partition(predicate :T => bool) :(:[T], :[T]) =>
    val passed = this.filter(predicate)
    val failed = this.filter(x => !predicate(x))
    (passed, failed)
end extension

{?} Usage:
val num = 42
printline(num.is-even)      {?} true
printline(5.factorial)      {?} 120

3.times(() => printline("Hello"))  {?} prints "Hello" three times

val text = "A man a plan a canal Panama"
printline(text.is-palindrome)      {?} true
printline(text.word-count)         {?} 6
printline(text.abbreviate(10))     {?} "A man a..."

val numbers = [1, 2, 3, 4, 5]
printline(numbers.second)          {?} some(2)
val (evens, odds) = numbers.partition(n => n.is-even)
printline(evens)                   {?} [2, 4]
printline(odds)                    {?} [1, 3, 5]
```
