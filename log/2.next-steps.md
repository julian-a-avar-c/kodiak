# Next steps

## Type parameterizing arrays

```kodiak
val greet-texts :array[text] = array[:text](3)
set greet-texts[0] = "[Hello]
set greet-texts[1] = "[, ]
set greet-texts[2] = "[world!\n]

for i = 0 to 2 do
  print(greet-texts[i])
```

```kodiak
val greet-texts :array[text] = array[:text](3)
greet-texts.update(0, "[Hello])
greet-texts.update(1, "[, ])
greet-texts.update(2, "[world!\n])

for (i = 0.to(2)) {
  print(greet-texts.apply[i])
}
```

```kodiak
val numNames = array("zero, "one, "two)
val numNames2 = array \ ("zero, "one, "two)
val numNames3 = array.apply("zero, "one, "two)
```

```kodiak
seq.empty
[]

val thrill = ["Will, "fill, "until]
["a, "b] ++ ["c, "d]

thrill[2]
thrill.count(s => s.length == 4)
thrill.drop(2)
thrill.drop-left(2)
thrill.drop-right(2)
thrill.exists(s => s == "until)
thrill.filter(s => s.length == 4)
thrill.forall(s => s.ends-with("l"))
thrill.foreach(s => print(s))
thrill.foreach(print)
thrill.head
thrill.init
thrill.last
thrill.tail
thrill.head-option
thrill.last-option
thrill.length
thrill.map(s => s + "y)
thrill.to-str("[, ])
thrill.filter-not(s => s.length == 4)
thrill.reverse
thrill.sort-with((a, b) =>
  $0[0].to-lower < $1[0].to-lower)
```

## Tuples and plexes

```kodiak
val pair = (1, "one")
val as-int = pair.0
val as-text = pair.1

then
```

## `Set` and `Map`

```kodiak
val jet-set = {"Boeing, "Airbus}
set jet-set += "Lear
val query = jet-set.contains("Cessna) {?} false
```

```kodiak
val treasure-map :[{[:id :int]: typeof id}] = {}
set treasure-map += { 1 = "[Go to island.] }
set treasure-map += { 2 = "[Find big X on ground.] }
set treasure-map += { 3 = "[Dig.] }
val step-2        = treasure-map[2] {?} "Find big X on ground."
```

```kodiak
val roman-numeral = map {
  1 = "I, 2 = "II, 3 = "III, 4 = "IV, 5 = "V,
}
val four = roman-numeral{4} {?} "IV
```

## Transformations with `map` and `for`

```kodiak
val adjectives = ["One, "Two, "Red, "Blue]

{?} You could transform it into a new list of new strings like this:

val nouns = adjectives.map(adj => adj + "[ Fish])
{?} ["[One Fish], "[Two Fish], "[Red Fish], "[Blue Fish]]

{?} Another way to perform this transformation is to use a for expression in which you introduce the body with the keyword yield instead of do:

val nouns =
  for adj = adjectives yield
    adj + "[ Fish]
{?} ["[One Fish], "[Two Fish], "[Red Fish], "[Blue Fish]]
```

```kodiak
val ques = vector["Who, "What, "When, "Where, "Why]
val using-map =
  ques.map { q :text =>
    q.to-lower-case + "? }
{?} vector["[who?], "[what?], "[when?], "[where?], "[why?]]

val using-for-yield =
  for q .= ques yield
    q.to-lower-case + "?
{?} vector["[who?], "[what?], "[when?], "[where?], "[why?]]
```
