# OOP

## Plexes, fields, and methods

```kodiak
plex checksum-accumulator() =>
  private var sum = 0
  fn add(b :int8) :unit => sum += b
  fn checksum :int64 => ~(sum & x#ff) + 1
end checksum-accumulator

val acc = :checksum-accumulator()
val csa = :checksum-accumulator()
```

## Semicolon inference

In Kodiak, semicolons are optional in most cases. The compiler can infer where statements end based on line breaks and context:

```kodiak
{?} These are equivalent:
val x = 42
val y = 24

val x = 42;
val y = 24;

{?} Semicolons are required when multiple statements are on the same line:
val a = 1; val b = 2; val c = 3

{?} Or when a statement continues on the next line in an ambiguous way:
val result = someFunction(param1,
  param2, param3)

{?} But not needed for obvious continuations:
val longExpression = someValue +
  anotherValue +
  yetAnotherValue
```

## Singleton plex

A singleton plex is a plex with only one instance. It's useful for implementing utility classes or global state:

```kodiak
plex logger =
  private var log-level = "INFO"

  fn set-level(level :text) :unit =>
    set log-level = level

  fn info(message :text) :unit =>
    if log-level == "INFO or log-level == "DEBUG then
      printline("[[INFO] $message])

  fn debug(message :text) :unit =>
    if log-level == "DEBUG then
      printline("[[DEBUG] $message])

  fn error(message :text) :unit =>
    printline("[[ERROR] $message])
end logger

{?} Usage:
logger.set-level("DEBUG)
logger.info("[Application started])
logger.debug("[Processing user input])
logger.error("[Something went wrong])
```

## Data plex

A data plex is primarily used to hold data with minimal behavior. It's similar to a record or struct in other languages:

```kodiak
data plex person(name :text, age :int, email :text) =>
  fn to-string :text =>
    "$name ($(age.to-string)) - $email"

  fn is-adult :bool =>
    age >= 18

  fn greet :text =>
    "[Hello, my name is $name]
end person

{?} Usage:
val john = :person("[John Doe], 25, "[john@example.com])
val jane = :person("[Jane Smith], 17, "[jane@example.com])

printline(john.to-string)    {?} "[John Doe (25) - john@example.com]
printline(john.is-adult)     {?} true
printline(jane.is-adult)     {?} false
printline(john.greet)        {?} "[Hello, my name is John Doe]
```

You can also create data plexes with mutable fields:

```kodiak
plex counter(initial-value :int) =>
  var value = initial-value

  fn increment :unit =>
    set value += 1

  fn decrement :unit =>
    set value -= 1

  fn get-value :int => value

  fn reset :unit =>
    set value = initial-value
end counter

{?} Usage:
val count = :counter(0)
count.increment
count.increment
printline(count.get-value)   {?} 2
count.reset
printline(count.get-value)   {?} 0
```
