# Kodiak Language Summary

Kodiak is a modern programming language that combines functional and object-oriented paradigms with clean, expressive syntax. This summary covers the core features and concepts of the language.

## Comments

Kodiak supports two types of comments:
- Single-line comments: `{?} This is a comment`
- Multi-line comments: `{? This is a multi-line comment ?}`

## Variables and Mutability

Kodiak distinguishes between mutable and immutable variables:
- `var x :int = 10` - mutable variable (can be reassigned with `set`)
- `val y :int = 20` - immutable variable (cannot be reassigned)

Use `set` to reassign mutable variables: `set x = 30`

## Type System

### Basic Types
- **Integers**: `int8`, `int16`, `int64`, `int`
- **Floating-point**: `dec32`, `dec64`, `dec`
- **Boolean**: `bool` (`true`, `false`)
- **Text**: `text` with interpolation support `"[Hello, ${name}!]`
- **Unit**: `unit` represents no meaningful value `()`

### Collections
- **Seqs**: `:seq(:text)`, `:[:text]`
- **Sets**: `:set(:text, :int)`, `:{:text, :int}`
- **Tuples**: `:tuple(:text, :int, :bool)`, `:(:text, :int, :bool)`

### Type Parameterization
Collections can be parameterized: `:seq(:text)`, `:set(:text, :int)`, `:tuple(:text, :int, :bool)`.

## Functions

Functions are defined with the `fn` keyword:

```kodiak
fn max(a :int, b :int) :int => {
  if a > b then a
  else b
}

{?} Type inference often allows omitting return types
fn greet(name :text) => "Hello, ${name}!"

{?} Functions without parameters
fn current-time :unit => printline(time.now)
```

## Control Flow

### Conditional Expressions
```kodiak
if condition then
  action1()
else if other-condition then
  action2()
else
  action3()
```

### Loops
```kodiak
{?} While loop
while i < 10 do
  printline(i)
  set i += 1

{?} For loop with range
for i = 1 to 10 do
  printline(i)

{?} For loop with range using `let`
for let i = 1 to 10 do
  printline(i)

{?} For loop with range using `let` and `step`
for let i = 1 to 10 step 2 do
  printline(i)

{?} For loop with collection
for item = collection do
  printline(item)

{?} Foreach
items.foreach(item => printline(item))
items.foreach(printline)  {?} Method reference shorthand
```

### Pattern Matching
```kodiak
match value
  with 1 then "one
  with n :int then "[integer: $n]
  with s :text then "[text: $s]
  with [head, ..tail] then "[list starting with $head]
  with :person { name, age } then "[person named $name]
  with _ >= 10 then "[large number]
  else "unknown
```

## Object-Oriented Programming

### Plexes (Classes)
Plexes are Kodiak's primary abstraction for object-oriented programming:

```kodiak
{?} Basic plex
plex person(name :text, age :int) =>
  fn greet :text => "[Hello, I'm $name]
  fn is-adult? :bool => age >= 18
end person

{?} Plex with mutable state
plex counter(initial :int) =>
  var count = initial
  fn increment :unit => set count += 1
  fn get-value :int => count
end counter

{?} Singleton plex
plex logger =
  private var level = "INFO
  fn log(message :text) :unit => printline("[[$level] $message])
end logger
```

### Access Control
- `private` - accessible only within the plex
- `public` (default) - accessible from outside

### Operators as Methods
Plexes can define operators as methods:

```kodiak
plex rational(n :int, d :int) =>
  fn +(other :rational) :rational => {?} addition logic
  fn -(other :rational) :rational => {?} subtraction logic
  fn ==(other :rational) :bool => {?} equality logic
end rational
```

## Functional Programming Features

### Higher-Order Functions
```kodiak
val numbers = [1, 2, 3, 4, 5]
val doubled = numbers.map(n => n * 2)
val evens = numbers.filter(n => n % 2 == 0)
val sum = numbers.fold(0)((acc, n) => acc + n)

{?} If all parameter names are irrelevant, then we can write underscores instead
val sum = numbers.fold(0)(_ + _)
```

### For Expressions with Yield
```kodiak
val squares = for i = 1 to 10 yield i * i
val filtered = for x = collection if x > 5 yield x * 2
```

## Text and Interpolation

Kodiak provides rich text manipulation:
- String interpolation: `"[Value: ${expression}]`
- Raw strings: `r"[No escapes: \n \t]`
- Multi-line strings: `"[Multi-line text]`

## Extension Methods

Add methods to existing types:

```kodiak
extension int =>
  fn is-even? :bool => this % 2 == 0
  fn factorial :int =>
    if this <= 1 then 1
    else this * (this - 1).factorial
end extension

{?} Usage: 5.factorial, 42.is-even?
```

## Method Overloading

Methods can be overloaded based on parameter types:

```kodiak
plex calculator =
  fn add(a :int, b :int) :int => a + b
  fn add(a :float64, b :float64) :float64 => a + b
  fn add(numbers :[int]) :int => numbers.sum
end calculator
```

## Literals and Syntax

### Numeric Literals
- Decimal: `42`, `3.14`
- Hexadecimal: `x#FF`
- Binary: `b#1010`
- Octal: `o#77`
- Scientific: `1.23e-4`

### Collection Literals
- Lists: `[1, 2, 3]`
- Sets: `{1, 2, 3}`
- Maps: `{key1 = value1, key2 = value2}`
- Tuples: `("a, "b, "c, 7)`

## Operators

### Arithmetic
`+`, `-`, `*`, `/`, `%` (modulo)

### Comparison
`==`, `!=`, `<`, `<=`, `>`, `>=`, `===` (reference equality)

### Logical
`&&` (and), `||` (or), `!` (not)

### Bitwise
`&` (and), `|` (or), `^` (xor), `~` (not), `<<` (left shift), `>>` (right shift)

## Semicolon Inference

Kodiak uses semicolon inference - semicolons are optional in most cases:

```kodiak
{?} These are equivalent:
val x = 42
val y = 24

val x = 42;
val y = 24;

{?} Required for multiple statements on same line:
val a = 1; val b = 2; val c = 3
```

## Error Handling

Kodiak uses exceptions for error handling:

```kodiak
try
  risky-operation()
catch e :io-exception then
  printline("IO error: ${e.message}")
catch e :exception then
  printline("General error: ${e.message}")

You can also use try by itself if the enclosing function has the capability to handle errors:

fn risky-operation() throws {
  try attempt-risky-operation()
}
```

## Identifiers

Kodiak supports flexible identifier naming:
- Standard: `variable-name`, `camelCase`, `snake_case`
- Unicode: `π`, `α`, `∑`
- Escaped keywords: `type`, `match`, `if`
- Operators as names: `+`, `<=>`, `to-string`
